
# Flamingo: Multi-Round Single-Server Secure  Aggregation with Applications to Private Federated  Learning --(S&P23)
speaker: DingJun| &emsp;2024.1.3



#1、介绍

## 安全聚合
$[z]$表示整数${1,2,\cdots,z}$，在训练开始前先确定$N$个用户，每个客户端以$[N]$中的数字为索引，训练过程总共有$T$轮组成。每一轮$t \in [T]$中，从$N$个用户中随机抽取一组用户，记为$S_t$，每个$S_t$中的用户都有一个输入向量$x_{i,t}$（客户可以在多轮中被选中，在每轮中也可能有不同的输入）。每一轮服务器想要安全地计算输入向量的和$\sum_{i \in S_t} x_{i,t}$。
联邦学习中的安全聚合面临以下诸多挑战：
- 大量的客户端
- 高纬度的输入向量
- 不稳定、连接不好的设备
- 模型收敛之前的多轮聚合
- 恶意客户端的篡改或攻击
---

## 本文的目标和创新
Flamingo专注于在联邦学习中安全聚合的多轮设置，比如一次性设置阶段和用于计算多个总和的收集过程，这样在设置中建立的秘密可以在整个收集过程中被重用。Flamingo使用一种轻量级协议，选择少量随机选择的客户端(解密器)与服务器交互以删除掩码，虽然它还是沿用了双掩码的经典操作。但与之前工作不同的是，Flamingo在设置中建立的秘密可以被重用，消除了对每次聚合的设置阶段的需要，减少了整个训练过程中的步骤数，整个收集过程中客户端只与服务器通信一次，在聚合阶段，服务器和一些作为解密器的客户端之间执行协议，减少了通信开销和训练时间。

---


#2、 问题陈述

### 通信模型
每个客户机都通过一个私有的、经过验证的通道与服务器通信，**从客户机发送到其他客户机的消息通过服务器转发**，并进行端到端的加密和身份验证。

### 威胁模型
我们对两种类型的故障进行建模:(1)由于网络条件不稳定、电源丢失等原因导致断开连接或响应太慢的诚实客户端;(2)控制服务器和有限部分客户端的对手的任意行为。

**Dropout** 系统中有两种类型的客户端：
- 普通客户端：提供输入向量，掉线率不超过$\delta$
- 解密器：帮助服务器恢复最终结果，掉线率不超过$\delta_D$

**Adversary**  假设有一个静态的恶意对手，破坏了服务器和$\eta$比例的客户端(总共有N个客户端)，也就是说，攻击者控制$N\eta$个客户端独立于协议执行。
区分两种客户端掉线的比例：
- ==腐败的普通客户端$(\eta S_t)$==
- ==损坏的解密器$(\eta D)$==
$\eta  S_t \approx \eta$

**阈值要求** Flamingo的最低工作要求是$\delta_D + \eta_D < 1/3$，<u>也即是说解密器的掉线率和腐败率总和要少于1/3.</u>

**和的精度** 如果最后的结果包含$\tau$比例的客户端(被选中并参与该轮$\tau |S_t|$)，则说这一轮的聚和有和精度$\tau$。

**输入的正确性** 在联邦学习的上下文中，如果恶意客户端输入虚假的权重，那么服务器可能会得出一个错误的模型(甚至可能包含导致模型分类错误某些输入的“后门”)，这篇文章并没有针对后门攻击提出方案。这不是它的重点。

---

# 3、背景
## 密码工具
- 伪随机数生成器(Pseudorandom generators)：PRG是一个确定性函数，接受$\{0,1\}^{\lambda}$中的随机种子，并输出一个较长的字符串，该字符串在计算上与随机字符串无法区分($\lambda$ 是计算安全性参数)
<br>

- 伪随机函数(Pseudorandom functions)：$PRF: \mathcal{K} \times \mathcal{X} \rightarrow \mathcal{Y}$，由$\mathcal{K}$中的键索引的一组确定性函数，将$\mathcal{X}$中的输入映射到$\mathcal{Y}$中。索引函数与从$\mathcal{X}$到 $\mathcal{Y}$的真正随机函数是无法区分的。
<br>

- Shamir 秘密分享：$Share(s,l,L) \rightarrow (s_1,\cdots,s_L)$ 
<br>

- DH密钥协商：Alice：私钥$a$和公钥$g^a$ &nbsp; Bob:私钥$b$和公钥$g^b$。(基于DDH困难假设)$(g^a)^b=(g^b)^a$---- 双方协商掩码的常规方法


## BBGLR协议
联邦学习设置中用于**单轮安全聚合**的最新协议。这个方案是谷歌那个双掩码方案的一个改进，把通信结构优化成了稀疏图。
成对掩码---> 掩码向量 ---> 聚合抵消

客户端$i$向服务器发送以下向量：

$$Vec_i=\overrightarrow{x_i}+\underbrace{\sum_{j \in A(i),i<j}PRG(r_{i,j})-\sum_{j \in A(i),i>j}PRG(r_{i,j})}_{pairwise \ mask}+\underbrace{PRG(m_i)}_{individual\ mask}$$

### 设置阶段(三步骤)
(1) 创建包含所有n个客户端的公钥的数据库;
(2) 创建一个无向图，其中每个顶点都是客户端，并且每个顶点都有足够的边来满足某些属性;
(3) 每个客户端向图中的邻居发送两个共享;

每个客户端$i$的DH私钥为$a_i$，向邻居共享私钥$a_i$和$m_i$。

### 收集阶段(三步骤)
(1)客户端向服务器发送掩码后的向量

(2)然后，服务器将接收到的所有向量求和，从而产生一个包含掩码和的向为了恢复正确的总和，服务器需要一种移除掩码的方法。<u>它通过向每个离线客户端$i$请求从$i$的邻居那里获得私钥$a_i$的份额;对于每个在线客户机$j$, 从$j$的邻居那里获得$m_j$的份额。这些共享允许服务器为每个客户端重构成对掩码或单个掩码。只要发送请求的共享的邻居数大于$l$，服务器就可以成功地移除掩码并获得总和。</u>()

**BBGLR只适合单轮训练**，多轮训练有几个问题：
- 每一轮派生出新的图，必须共享新的秘密，而且秘密不能重用，否则可能会暴露用户的输入，掩码是一次性的。
<br>
- BBGLR的威胁模型不能自然地扩展到多轮聚合。假设在$t$轮中，假设客户端$i$有邻居$j_1,j_2,\cdots,j_y$，恶意服务器对$j_1,j_2,\cdots,j_y$说谎$i$已经退出，那么$i$的邻居将提供对应$a_i$的份额，服务器可以重建$a_i$；类似地，服务器告诉$j_1,j_2,\cdots,j_y$客户端$i$在线并且请求$m_i$的分享，此时服务器重建两个掩码从而恢复输入向量 $x$。所以BBGLR在每个客户端的所有邻居之间执行一致性检查cross-check，对节点的在线-离线情况达成一致，防止恶意服务器的欺骗。
<br>
- 所以说，抵御恶意攻击的BBGLR需要六步骤，设置三步、收集三步。
<br>

- 这种服务器向客户端多次交流请求秘密份额的方法并不高效也只适用于单轮安全聚合设置。

---

# 4、多轮安全聚合

Flamingo支持多轮聚合，而无需为每轮重新设置，并且可以在整个过程中抵御恶意对手。所需的假设是:(1)在设置中，所有各方都从可信来源，获得相同的随机种子;(2) PKI(例如，密钥透明度日志)。下面我们描述支撑Flamingo(4.1)的高级思想，然后我们给出完整的协议。

## 主要思想

1） 轻量级的掉线弹性
~~要求客户端与所有邻居共享掩码$a_i$和$m_i$~~
==加密它们成对的和私有的掩码的PRG种子== $\rightarrow$  得到的密文附加到掩码向量上 $\rightarrow$ 交给服务器
在一组特殊的$L$个客户端(解密器)的帮助下，服务器可以解密与每个屏蔽输入向量相关的两个种子中的一个，但不能同时解密两个种子(否则会暴露客户端的初始输入向量)。

**DKG(ElGamal密码系统和Shamir秘密共享)**

==非对称加密方案(AsymEnc)阈值解密==
$PK$:系统范围内已知
$SK$:在解密器之间共享(阈值解密 $l \ out \ of \ L$)
- 客户端使用$PK$加密数据，传给服务器；
- 服务器将密文(从提交的向量中提取)发送给每个解密器，==从$L$个解密器中获得阈值$l$个响应，并在本地组合$l$个响应生成相应的明文==
- 这种设计改进了BBGLR的运行时间，因为它不需要让所有客户端都来删除掩码——服务器只需要等待，直到它从解密器收集到足够的共享，而不用等待几乎所有共享都到达。此外，将几个小密文(每个64 bytes)附加到一个大的输入向量(数百kb)的通信开销是很小的。

2）可重用的秘密
目标：<mark>消除每一轮聚合的设置阶段</mark>，因为联邦学习为每一轮聚合选择不同的客户端集合。
-  将$r_{ij}$视为长期的秘密，客户端$i$第$t$轮成对掩码的种子为$h_{i,j,t}=PRF(r_{i,j},t), j \in A(i)$，每个客户端为第$t$轮生成新的私有掩码$m_{it}$。
$r_{i,j}$作为一个长期秘密的一个很好的特性是Flamingo可以避免在图邻居之间执行所有的Diffie-Hellman密钥交换

3）生成每轮的图
FL中，建立稀疏图需要每轮生成，一个简单的方法是让$[N]$中所有的客户端在设置阶段建立一个具有$N$个节点的大图$G$，每个客户端将其选择的$\gamma$个邻居发送给服务器，服务器将相应的邻居发送给每个客户端，然后$t$轮对应的子图$G_t$由$S_t$中的客户和客户之间的边组成。但是可能存在极端情况，过小的$\gamma$可能导致$G_t$不连接或者孤立节点；过大的$\gamma$导致$G_t$不是稀疏的(接近完全图($O(n^2)$))。
<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image43.png">
</img>
</div>

论文中引入了一种与$\gamma$无关的的方法，参数 $\epsilon$。

<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image44.png">
</img>
</div>

Flamingo的工作流程：服务器首先为系统中的所有客户机进行设置。在每一轮训练中，服务器安全地聚合报告步骤中被屏蔽的输入向量;在交叉检查和重建步骤中，服务器与一小组随机选择的客户端进行通信，这些客户端充当解密者。解密器的选择独立于在给定一轮中提供输入的集合$S_t$。每$R$轮，解密者交换，旧的解密者将SK的份额转移给新的解密者(Secret Key  Transfer)。


## PKI存储的类型
- 客户端$i$的公钥$g^{a_i}$，用于派生出==成对掩码==
- 客户端$i$的$g^{b_i}$，用于导出对称加密密钥$k_{i,j}$用于==认证加密方案==。当一个客户端通过服务器向另一个客户端发送消息时，使用此方案。
- 客户端$i$的$pk_i$，用于==验证签名==其对$sk_i$的签名消息。

---

## 设置阶段
1）向所有参与者分发随机种子$v \in \{0,1\}^{\lambda}$，
2）随机选择客户端子集作为解密器并分发非对称加密方案AsymEnc的秘钥共享，AsymEnc是ElGamal密码系统的加密函数。在$L$个解密器之间运行DKG协议。

**GJKR-DKG协议**
它的阈值是1/2，最多有一半的参与者可以不诚实。
其余必须正确执行以下步骤:(1)每一方$i$生成一个随机值$s_i$，并作为经销商分配$s_i$的股份($j$方获得$s_{i,j}$)。(2)每方$j$==验证收到的股份==。如果$i$方的份额未通过验证，$j$方广播对$i$方的投诉。(3)对于$j$方的每一项投诉，$i$方广播$s_{i,j}$进行验证。(四)对验证不合格的，各方取消其资格;其余各方形成一个固定的QUAL集合。然后，==各方对来自QUAL的共享进行汇总==，得到密钥的额一个分享。
本文对其进行了修改，给出修改版本。
它假设==不诚实参与者的阈值是1/3==，其次，所有消息都要经过签名；诚实的当事人如果没有收到规定的信息就会放弃。第三，我们在每个客户端决定最终的QUAL集合之前增加了一个步骤:所有各方对他们的QUAL集合签名并将其发送给服务器；服务器将签名的QUALs发送给各方。==然后，每一方检查它是否接收到$2(l + 1)$或更多相同的有效签名QUAL集==。如果是，那么QUAL集合定义一个秘密密钥;否则各方终止协议。GJKR-DKG的方便之处是我们允许各方中止(因此最后不会共享密钥)，这在联邦学习设置中是合理的，因为如果服务器行为不当，将无法获得结果。


$\prod_{DKG}$协议
参数：$L$个解密器，阈值$l$:$3l+1=L$,$\delta _D+\eta_D < 1/3$
输出：$L$个解密器拥有秘密$s$的一个分享份额$s_u$，以及用于加密掩码$PRG(h_{i,j,t})$的公钥$PK$
1、每个客户端本地都有一个秘密$s_i$，作为经销商分享秘密共享该秘密给其他用户，同时进行验证。
2、进行上述GJKR-DKG中的QUAL验证操作，如果成功，每个用户将获得的份额相加作为自己的秘密份额(SK的份额)，$x_j=\sum_{i \in QUAL} s_{ij}$； $PK=\prod_{i \in QUAL} g^{s_i}$
此时$L$个解密器拥有了SK的份额$s_1,s_2,\cdots,s_L$。在ElGamal中想要解密密文$(c_0,c_1)$，需要计算$c_0^{SK}$,然后计算明文$h=(c_0^{SK})^{-1} \cdot c_1$，此时$SK$被共享，通过以下操作进行阈值解密：
$$c_0^{SK}=\prod_{u \in U}(c_0^{su})^{\beta^u}$$
$c_0^{su}$是在解密器本地计算的，然后发送给服务器进行组合系数恢复，在重建过程中，服务器只使用部分共享进行重建，多余的共享将会被丢弃，而且股份的线性组合可以并行完成(插值系数的计算)。

(https://zhuanlan.zhihu.com/p/38148593)。

- $SK$从未被重构
- 解密是可掉线的，只要超过$l$个响应
- 只与解密器通信一次，非交互式


## 收集阶段
收集阶段包括$T$轮，每一轮$t$有三步：==report,cross-check,reconstruction==。
**Report** 在$t$轮中，服务器使用随机值$v$(从setup阶段获得)选择客户端集合$S_t$，大小$n_t$。然后建客户端之间的图。服务器向每个客户端$i \subseteq S_t$请求发送一个包括以下三个信息的消息：
1\) $Vec_i=\overrightarrow{x_{i,t}}+\sum_{j \in A_t(i)} \pm PRG(h_{i,j,t})+PRG(m_{i,t})$，其中$h_{i,j,t}=PRF(r_{i,j},t), r_{i,j}=(g^{a_i})^{a_j}$，$m_{it}$是是客户端在第$t$轮由客户端$i$新生成的。
2\)$L$个对称加密密文：==$SymAuthEnc(k_{i,u},m_{i,u,t}),\ u \in D$==，其中$m_{i,u,t}$是与$u$之间$m_{i,t}$的分享，==$k_{i,u}$是在客户端$i$和解密器$u$之间共享的对称加密密钥==(可以由PKI派生$k_{i,u}$)。
3\) $|A_t(i)|$个ElGamal 密文：AsymEnc($PK,h_{i,j,t}$)，对于所有$j \in A(i)$。
上述对单个掩码使用对称加密，对成对掩码使用公钥加密的方法是为了在实践中平衡计算和通信。

---

**Cross-check**  服务器需要==恢复在线客户端的$m_{i,t}$和退出客户端的$h_{i,j,t}$==。为此，服务器将客户端标记为“离线”或“在线”，并要求解密器恢复相应的掩码。对于BBGLR，恶意服务器可以向客户端发送不一致的标签，并为某些目标客户端恢复成对掩码和单个掩码。Flamingo还需要处理这种类型的攻击(==服务器告诉一些诚实的解密者解密$m_{it}$，并告诉其他诚实的解密者解密$h_{i,j,t}$，并利用恶意的解密者重建两者==)，但它只需要涉及解密者。详细地说，每个解密者对$n_t$个客户机的在线/离线标签进行签名(每个客户机只能标记为离线或在线)，并将它们发送给其他解密者(通过服务器)。==每一个解密器检查是否收到了$2L/3$或更多有效的签名标签($\delta_D+\eta_D < 1/3$)==。如果是，每个解密器进一步检查：
1\) 在线的客户端数量至少为$(1-\delta)n_t$;
2\) 图中所有在线客户端都是连通的;
3\) 每个在线客户端$i$至少有$k$个在线邻居，使得$η^k < 2^{−κ}$(η和κ的定义见2.3)。
如果上述任何检查失败，解密程序将终止。==此步骤确保所有诚实的解密者同意有效的离线/在线标签分配==，从而服务器获得结果，或者诚实的解密器中止，服务器什么也得不到。
**Reconstruction** 服务器收集所有需要解密的密文:==在线客户端的密文$m_{i,u,t}$(对称加密)==，==离线客户端的密文$h_{i,j,t}$(公钥加密)==。然后，服务器将密文发送给所有的解密器，这些解密器根据他们==商定的标签执行对称解密或阈值ElGamal解密==。选择使用解密器来检查图并重建所有秘密是基于联邦学习中的一个重要观察:一轮中涉及的客户端数量$n_t$远小于输入向量长度[43]。因此，解密器的渐近代价(与$n_t$成正比)实际上小于输入权向量的大小。

### 跨回合的恶意标记
恶意服务器：
$t$轮解密$h_{i,j,t}$ &nbsp;&nbsp; $\rightarrow$&nbsp;&nbsp; 在另一个$t'$轮中要求对$m_{i,t}$进行解密  &nbsp;&nbsp;$\rightarrow$ &nbsp;&nbsp;恢复$x_{it}$

为了防止这种攻击，诚实的解密者需要知道发送密文的那一轮。
-  对于对称密文，客户端将轮数$t$附加到明文(例如$m_{i,u,t} ||t$)并使用经过认证的加密;
- 对于公钥密文，客户端在密文$c$后面加上$t$，并对元组$(c,t)$签名(验证密钥在PKI中)。请注意，恶意的攻击者仍然可以欺骗足够多的诚实的解密器使它认为现在是第$t$轮，而实际上它是$t '$轮。为了防止这种情况，解密器还在==在线/离线标签中包含轮数$t$并对其进行签名==。交叉检查保证解密器在轮数上达成一致。

---


# 5、结果
### 实验环境
在一台具有40个Intel Xeon E5-2660 v3 (2.60GHz) cpu和200 GB DDR4内存的服务器上运行ABIDES模拟器。ABIDES支持立方网络延迟模型:延迟包括一个基本延迟(一个范围)，加上一个控制在给定时间内到达的消息百分比的抖动(即延迟分布尾部的形状)。我们将基本延迟设置为ABIDES默认参数中的“全局”设置(**范围为21微秒到53毫秒**)，并使用默认参数进行抖动。


<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image45.png">
</img>
</div>

参数：$N$是客户端总数，$n_t$是第$t$轮被选中参与FL的客户端；$L$解密器数量；$S_t$掉线率是$\delta$；$d$是客户端输入向量的维度；

BBGLR和Flamingo的T轮聚合总渐近代价变化不大;
- 但是round-trips(客户端和服务器通信)的数量差别很大。==Flamingo需要更少的往返通信次数。==
BBGLR一次求和要6次往返，Flamingo只要3次(cross-check和传送解密消息)
- 重建阶段的等待时间减少，BBGLR中服务器必须等待绝大多数客户端响应才能重建秘密，而Flamingo中的服务器只要1/3的解密器的响应，而且解密器的数量在整体客户端中的数量占比较小。


将$N=10K$，解密器数量为60，Flamingo和BBGLR的邻居数量为$4log \ n_t$

**单论聚合的通信开销**
N=1K个客户端，客户端掉线率$\delta=1 \%$
给出了单个求和的通信成本。BBGLR和Flamingo每轮聚合的总成本是相似的。这是因为Flamingo在report步骤上对BBGLR的额外成本大致相当于BBGLR在其三步设置中的消息大小;
但是与BBGLR相比，Flamingo在大致相同的服务器通信总量下具有更少的往返。在report步骤中，每个客户端在Flamingo中的成本略高于BBGLR，因为Flamingo中的客户端需要将密文附加到向量上。
在重建步骤中，不是解密器的客户机将不需要发送或接收任何消息。每个解密器引发的通信比发送一个输入向量略大。
<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image46.png">
</img>
</div>


**聚合完成时间**
为了展示等待时间w如何影响退出(从而影响求和的准确性)，我们使用两个等待时间，5秒和10秒。聚合轮的运行时间取决于每个步骤的超时、模拟的网络延迟以及服务器和客户端的计算时间。展示了跨10轮聚合的总体完成时间。更短的等待时间使训练更快，但这也意味着有更多的退出率，这反过来又导致重建过程中更多的计算。因此，这两种情况的总体运行时是相似的。
在1K客户端上，Flamingo比BBGLR提高了3倍;对于Flamingo的成本，我们包括了它的一次性设置和一次密钥传输。如果执行密钥传输的频率较低，则改进将更加显著。

==说明了影响聚合端到端完成时间的一个关键因素是客户机和服务器之间的往返次数==

<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image-47.png">
</img>
</div>


  DKG过程(设置的一部分，我们也将其添加到图8中的第一轮)的成本如图9所示。一个完整的DKG需要不到10秒的时间，因为解密器的数量不多，并且我们允许解密器退出。对于60个解密器，每个解密器在DKG期间执行的本地计算为2秒。
<div align="center" >
<img width=600px  height=auto src="https://raw.githubusercontent.com/moon-Light404/read_paper_notes/master/note_image/image-48.png">
</img>
</div>